import React, { createContext, useContext, useReducer, ReactNode, useEffect } from 'react';
import { toast } from '@/hooks/use-toast';
import * as db from '@/lib/db';
import {
  calculateSubtotal,
  calculateTaxAmount,
  calculateTotal
} from '@/lib/calculations';
import { returnCashierStock } from '@/lib/returnStock';
import * as stockManagement from '@/lib/stockManagement';
import { useAuth } from './AuthContext';
import { supabase } from '@/lib/supabase';

export interface CashierStock {
  cashier_id: string;
  product_id: string;
  stock: number;
  created_at: string;
  updated_at: string;
}

export interface StockDistribution {
  id: string;
  product_id: string;
  cashier_id: string;
  quantity: number;
  distributed_by: string;
  distributed_at: string;
}

export interface Product {
  id: string;
  name: string;
  price: number;
  storage_stock: number;
  category: string;
  sku: string;
  description?: string;
  image?: string;
  cashier_stock: Record<string, number>;
  total_stock?: number;
  stock?: number; // For compatibility with cart operations
}

export interface StockReturn {
  id: string;
  product_id: string;
  cashier_id: string;
  quantity: number;
  reason: string;
  returned_at: string;
  created_by: string;
}

export interface CartItem {
  product: Product;
  quantity: number;
}

export interface TaxType {
  id: string;
  name: string;
  rate: number;
}

export interface SaleTax {
  id: string;
  saleId: string;
  taxTypeId: string;
  taxAmount: number;
  tax_types?: TaxType;
}

export interface TaxType {
  id: string;
  name: string;
  rate: number;
  enabled?: boolean;
}

export interface SaleItem {
  id: string;
  sale_id: string;
  product_id: string;
  quantity: number;
  price_at_time: number;
  product?: Product;
}

export interface Sale {
  id: string;
  created_at: string;
  total: number;
  subtotal: number;
  tax_amount: number;
  payment_method: 'cash' | 'card' | 'qris';
  cashier_id: string;
  status: 'completed' | 'cancelled' | 'pending';
  sale_items: SaleItem[];
  sales_taxes: SaleTax[];
}

export interface Cashier {
  id: string;
  email: string;
  username?: string;
  full_name?: string;
  role: string;
}

export interface TaxSettings {
  taxTypes: TaxType[];
}

interface POSState {
  products: Product[];
  cart: CartItem[];
  sales: Sale[];
  cashiers: Cashier[];
  taxSettings: TaxSettings;
  isLoading: boolean;
  error: string | null;
}

interface POSContextType {
  state: POSState;
  addProduct: (product: Omit<Product, 'id'>) => Promise<void>;
  updateProduct: (id: string, product: Partial<Product>) => Promise<void>;
  deleteProduct: (id: string) => Promise<void>;
  fetchProducts: () => Promise<void>;
  addToCart: (product: Product, quantity?: number) => void;
  updateCartItem: (product: Product, quantity: number) => void;
  removeFromCart: (productId: string) => void;
  clearCart: () => void;
  completeSale: (sale: Sale) => Promise<void>;
  calculateTotals: () => { subtotal: number; taxes: SaleTax[]; total: number };
  distributeStock: (productId: string, cashierId: string, quantity: number) => Promise<void>;
  updateProductStorage: (
    productId: string,
    quantity: number,
    reason: string
  ) => Promise<{
    success: boolean;
    previous_stock: number;
    new_stock: number;
    change: number;
    product: Product;
  }>;
  returnCashierStock: (
    productId: string,
    quantity: number,
    reason: string
  ) => Promise<{
    success: boolean;
    previous_stock?: number;
    new_stock?: number;
    returned_quantity?: number;
    error?: string;
  }>;
}

type POSAction =
  | { type: 'SET_LOADING'; loading: boolean }
  | { type: 'SET_ERROR'; error: string | null }
  | { type: 'SET_PRODUCTS'; products: Product[] }
  | { type: 'SET_SALES'; sales: Sale[] }
  | { type: 'SET_CASHIERS'; cashiers: Cashier[] }
  | { type: 'SET_TAX_SETTINGS'; taxSettings: TaxSettings }
  | { type: 'ADD_PRODUCT'; product: Product }
  | { type: 'UPDATE_PRODUCT'; id: string; product: Partial<Product> }
  | { type: 'DELETE_PRODUCT'; id: string }
  | { type: 'ADD_TO_CART'; product: Product; quantity: number }
  | { type: 'UPDATE_CART_ITEM'; productId: string; quantity: number }
  | { type: 'REMOVE_FROM_CART'; productId: string }
  | { type: 'CLEAR_CART' }
  | { type: 'ADD_SALE'; sale: Sale }
  | { type: 'UPDATE_SALE'; id: string; sale: Partial<Sale> }
  | { type: 'DELETE_SALE'; id: string };

const initialState: POSState = {
  products: [],
  cart: [],
  sales: [],
  cashiers: [],
  taxSettings: {
    taxTypes: []
  },
  isLoading: true,
  error: null
};

const posReducer = (state: POSState, action: POSAction): POSState => {
  switch (action.type) {
    case 'SET_CASHIERS':
      return {
        ...state,
        cashiers: action.cashiers
      };

    case 'ADD_PRODUCT':
      return {
        ...state,
        products: [...state.products, action.product]
      };

    case 'UPDATE_PRODUCT':
      return {
        ...state,
        products: state.products.map(p =>
          p.id === action.id 
            ? { 
                ...p, 
                ...action.product,
                // Preserve storage_stock if not explicitly updated
                storage_stock: action.product.storage_stock !== undefined 
                  ? action.product.storage_stock 
                  : p.storage_stock,
                // Update total_stock calculation
                total_stock: (action.product.storage_stock !== undefined 
                  ? action.product.storage_stock 
                  : p.storage_stock) + 
                  Object.values(p.cashier_stock || {}).reduce((sum, qty) => sum + qty, 0)
              } 
            : p
        )
      };

    case 'DELETE_PRODUCT':
      return {
        ...state,
        products: state.products.filter(p => p.id !== action.id)
      };

    case 'ADD_TO_CART': {
      const existingItem = state.cart.find(item => item.product.id === action.product.id);
      
      // Get the current user's cashier stock
      const cashierStock = action.product.cashier_stock ? 
        Object.values(action.product.cashier_stock)[0] || 0 : 0;

      if (existingItem) {
        const newQuantity = existingItem.quantity + action.quantity;
        if (newQuantity > cashierStock) {
          toast({
            title: "Stok Tidak Mencukupi",
            description: `Stok tersedia: ${cashierStock} item`,
            variant: "destructive"
          });
          return state;
        }
        
        return {
          ...state,
          cart: state.cart.map(item =>
            item.product.id === action.product.id
              ? { ...item, quantity: newQuantity }
              : item
          )
        };
      } else {
        if (action.quantity > cashierStock) {
          toast({
            title: "Stok Tidak Mencukupi",
            description: `Stok tersedia: ${cashierStock} item`,
            variant: "destructive"
          });
          return state;
        }
        
        return {
          ...state,
          cart: [...state.cart, { product: action.product, quantity: action.quantity }]
        };
      }
    }

    case 'UPDATE_CART_ITEM': {
      if (action.quantity <= 0) {
        return {
          ...state,
          cart: state.cart.filter(item => item.product.id !== action.productId)
        };
      }
      
      const product = state.products.find(p => p.id === action.productId);
      if (!product) return state;

      // Get the current user's cashier stock
      const cashierStock = product.cashier_stock ? 
        Object.values(product.cashier_stock)[0] || 0 : 0;

      if (action.quantity > cashierStock) {
        toast({
          title: "Stok Tidak Mencukupi",
          description: `Stok tersedia: ${cashierStock} item`,
          variant: "destructive"
        });
        return state;
      }
      
      return {
        ...state,
        cart: state.cart.map(item =>
          item.product.id === action.productId
            ? { ...item, quantity: action.quantity }
            : item
        )
      };
    }

    case 'REMOVE_FROM_CART':
      return {
        ...state,
        cart: state.cart.filter(item => item.product.id !== action.productId)
      };

    case 'CLEAR_CART':
      return {
        ...state,
        cart: []
      };

    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.loading
      };

    case 'SET_ERROR':
      return {
        ...state,
        error: action.error
      };

    case 'SET_PRODUCTS':
      return {
        ...state,
        products: action.products
      };

    case 'SET_SALES':
      return {
        ...state,
        sales: action.sales
      };

    case 'SET_TAX_SETTINGS':
      return {
        ...state,
        taxSettings: action.taxSettings
      };

    case 'UPDATE_SALE':
      return {
        ...state,
        sales: state.sales.map(sale =>
          sale.id === action.id ? { ...sale, ...action.sale } : sale
        )
      };

    case 'DELETE_SALE':
      return {
        ...state,
        sales: state.sales.filter(sale => sale.id !== action.id)
      };

    default:
      return state;
  }
};

interface POSContextType {
  state: POSState;
  addProduct: (product: Omit<Product, 'id'>) => Promise<void>;
  updateProduct: (id: string, product: Partial<Product>) => Promise<void>;
  deleteProduct: (id: string) => Promise<void>;
  fetchProducts: () => Promise<void>;
  addToCart: (product: Product, quantity?: number) => void;
  updateCartItem: (product: Product, quantity: number) => void;
  removeFromCart: (productId: string) => void;
  clearCart: () => void;
  completeSale: (sale: Sale) => Promise<void>;
  calculateTotals: () => { subtotal: number; taxes: SaleTax[]; total: number };
  distributeStock: (productId: string, cashierId: string, quantity: number) => Promise<void>;
  returnStock: (
    productId: string,
    quantity: number,
    reason: string
  ) => Promise<{
    success: boolean;
    previous_stock?: number;
    new_stock?: number;
    returned_quantity?: number;
    error?: string;
  }>;
}

const POSContext = createContext<POSContextType | undefined>(undefined);

export const POSProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(posReducer, initialState);

  // Initial data load
  useEffect(() => {
    const loadInitialData = async () => {
      dispatch({ type: 'SET_LOADING', loading: true });
      try {
        const [products, sales, cashiers, taxTypes] = await Promise.all([
          db.fetchProducts(),
          db.fetchSales(),
          db.fetchCashiers(),
          db.getTaxTypes()
        ]);

        dispatch({ type: 'SET_PRODUCTS', products });
        dispatch({ type: 'SET_SALES', sales });
        dispatch({ type: 'SET_CASHIERS', cashiers });
        dispatch({ 
          type: 'SET_TAX_SETTINGS', 
          taxSettings: { taxTypes } 
        });
      } catch (error) {
        dispatch({ type: 'SET_ERROR', error: (error as Error).message });
        toast({
          title: "Gagal Memuat Data",
          description: `Terjadi kesalahan saat memuat data: ${(error as Error).message}. Silakan coba lagi atau hubungi administrator jika masalah berlanjut.`,
          variant: "destructive"
        });
      } finally {
        dispatch({ type: 'SET_LOADING', loading: false });
      }
    };

    loadInitialData();
  }, []);

  const addProduct = async (product: Omit<Product, 'id'>) => {
    try {
      const newProduct = await db.addProduct(product);
      dispatch({ type: 'ADD_PRODUCT', product: newProduct });
      toast({
        title: "Produk Ditambahkan",
        description: "Produk baru berhasil ditambahkan",
      });
    } catch (error) {
      toast({
        title: "Gagal Menambahkan Produk",
        description: "Terjadi kesalahan saat menambahkan produk. Pastikan semua data telah diisi dengan benar dan tidak ada SKU yang duplikat.",
        variant: "destructive"
      });
      throw error;
    }
  };

  const updateProduct = async (id: string, product: Partial<Product>) => {
    try {
      const updatedProduct = await db.updateProduct(id, product);
      dispatch({ type: 'UPDATE_PRODUCT', id, product: updatedProduct });
      toast({
        title: "Produk Diperbarui",
        description: "Perubahan berhasil disimpan",
      });
    } catch (error) {
      toast({
        title: "Gagal Memperbarui Produk",
        description: "Terjadi kesalahan saat memperbarui produk",
        variant: "destructive"
      });
      throw error;
    }
  };

  const deleteProduct = async (id: string) => {
    try {
      await db.deleteProduct(id);
      dispatch({ type: 'DELETE_PRODUCT', id });
    } catch (error) {
      toast({
        title: "Gagal Menghapus Produk",
        description: "Terjadi kesalahan saat menghapus produk",
        variant: "destructive"
      });
      throw error;
    }
  };

  const addToCart = (product: Product, quantity: number = 1) => {
    dispatch({ type: 'ADD_TO_CART', product, quantity });
  };

  const updateCartItem = (product: Product, quantity: number) => {
    dispatch({ type: 'UPDATE_CART_ITEM', productId: product.id, quantity });
  };

  const removeFromCart = (productId: string) => {
    dispatch({ type: 'REMOVE_FROM_CART', productId });
  };

  const clearCart = () => {
    dispatch({ type: 'CLEAR_CART' });
  };

  const calculateTotals = () => {
    const subtotal = calculateSubtotal(state.cart);
    const enabledTaxTypes = state.taxSettings.taxTypes.filter(tax => tax.enabled);
    const taxes = enabledTaxTypes.map(tax => ({
      id: crypto.randomUUID(),
      saleId: '',
      taxTypeId: tax.id,
      taxAmount: calculateTaxAmount(subtotal, tax),
      tax_types: tax
    }));
    const total = calculateTotal(subtotal, enabledTaxTypes);

    return { subtotal, taxes, total };
  };

  const completeSale = async (paymentMethod: 'cash' | 'qris') => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');

      const { subtotal, taxes, total } = calculateTotals();
      const taxAmount = taxes.reduce((sum, tax) => sum + tax.taxAmount, 0);

      // Step 1: Create the sale record
      const { data: sale, error: saleError } = await supabase
        .from('sales')
        .insert({
          cashier_id: user.id,
          subtotal,
          tax_amount: taxAmount,
          total,
          payment_method: paymentMethod,
          status: 'completed',
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (saleError) throw saleError;

      // Step 2: Create sale items
      const saleItems = state.cart.map(item => ({
        sale_id: sale.id,
        product_id: item.product.id,
        quantity: item.quantity,
        price_at_time: item.product.price
      }));

      const { error: itemsError } = await supabase
        .from('sale_items')
        .insert(saleItems);

      if (itemsError) throw itemsError;

      // Step 3: Create sale taxes
      const saleTaxes = taxes.map(tax => ({
        sale_id: sale.id,
        tax_type_id: tax.taxTypeId,
        tax_amount: tax.taxAmount
      }));

      if (saleTaxes.length > 0) {
        const { error: taxError } = await supabase
          .from('sale_taxes')
          .insert(saleTaxes);

        if (taxError) throw taxError;
      }

      const { data, error } = await supabase
        .from('sales')
        .select(`
          *,
          sale_items (*),
          sale_taxes (*)
        `)
        .eq('id', sale.id)
        .single();

      if (error) throw error;

      // Update stock levels
      for (const item of state.cart) {
        await stockManagement.updateStorageStock(
          item.product.id,
          -item.quantity,
          `Sale #${data.id}`
        );
      }

      // Refresh products and clear cart
      const products = await db.fetchProducts();
      dispatch({ type: 'SET_PRODUCTS', products });
      clearCart();

      toast({
        title: "Success",
        description: `Sale #${data.id} completed successfully`
      });
    } catch (error) {
      toast({
        title: "Gagal Menyimpan Transaksi",
        description: error instanceof Error ? error.message : "Terjadi kesalahan saat menyimpan transaksi",
        variant: "destructive"
      });
      throw error;
    }
  };

  const updateSale = async (id: string, sale: Partial<Sale>) => {
    try {
      const updatedSale = await db.updateSale(id, sale);
      dispatch({ type: 'UPDATE_SALE', id, sale: updatedSale });
    } catch (error) {
      toast({
        title: "Gagal Memperbarui Transaksi",
        description: "Terjadi kesalahan saat memperbarui transaksi",
        variant: "destructive"
      });
      throw error;
    }
  };

  const deleteSale = async (id: string) => {
    try {
      await db.deleteSale(id);
      dispatch({ type: 'DELETE_SALE', id });
    } catch (error) {
      toast({
        title: "Gagal Menghapus Transaksi",
        description: "Terjadi kesalahan saat menghapus transaksi",
        variant: "destructive"
      });
      throw error;
    }
  };

  const refreshProducts = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Tidak ada user yang login');

      let products;
      if (user.user_metadata?.role === 'admin') {
        products = await db.fetchProducts();
      } else {
        const { fetchCashierProducts } = await import('@/lib/fetchCashierProducts');
        products = await fetchCashierProducts();
      }

      dispatch({ type: 'SET_PRODUCTS', products });
      return products;
    } catch (error) {
      console.error('Error refreshing products:', error);
      toast({
        title: "Gagal memperbarui data",
        description: "Terjadi kesalahan saat memuat ulang data produk",
        variant: "destructive"
      });
      throw error;
    }
  };

  const updateProductStorage = async (productId: string, quantity: number, reason: string) => {
    try {
      // Update stock and get the latest product data
      const result = await stockManagement.updateStorageStock(productId, quantity, reason);
      
      if (!result.success) {
        throw new Error(result.error || 'Gagal memperbarui stok');
      }

      // Get the updated product data
      const products = await refreshProducts();
      const updatedProduct = products.find(p => p.id === productId);
      
      if (!updatedProduct) {
        throw new Error('Produk tidak ditemukan setelah pembaruan');
      }

      // Show success message with stock details
      toast({
        title: "Stok Diperbarui",
        description: `Stok berhasil diubah dari ${result.previous_stock} menjadi ${result.new_stock} unit`,
      });

      return {
        ...result,
        product: updatedProduct
      };
    } catch (error) {
      console.error('Error in updateProductStorage:', error);
      toast({
        title: "Gagal Memperbarui Stok",
        description: error instanceof Error ? error.message : "Terjadi kesalahan saat memperbarui stok",
        variant: "destructive"
      });
      throw error;
    }
  };

  const distributeStock = async (productId: string, cashierId: string, quantity: number) => {
    try {
      const currentUser = (await supabase.auth.getUser()).data.user;
      if (!currentUser) throw new Error('No authenticated user');
      
      // Get current stock information before distribution
      const beforeStock = await stockManagement.getWarehouseStock(productId);
      
      // Distribute stock
      await stockManagement.distributeStock(productId, cashierId, quantity, currentUser.id);
      
      // Get updated stock information
      const products = await db.fetchProducts();
      const updatedProduct = products.find(p => p.id === productId);
      
      // Update state with new products data
      dispatch({ type: 'SET_PRODUCTS', products });
      
      // Show success message with stock details
      toast({
        title: "Stok Didistribusikan",
        description: `${quantity} unit berhasil didistribusikan. Sisa stok gudang: ${updatedProduct?.storage_stock || 0} unit`,
      });
    } catch (error) {
      toast({
        title: "Gagal Mendistribusikan Stok",
        description: error instanceof Error ? error.message : "Terjadi kesalahan saat mendistribusikan stok",
        variant: "destructive"
      });
      throw error;
    }
  };

  const value: POSContextType = {
    state,
    addProduct: async (product: Omit<Product, 'id'>) => {
      const result = await addProduct(product);
      return result;
    },
    updateProduct,
    refreshProducts,
    deleteProduct,
    addToCart,
    updateCartItem,
    removeFromCart,
    clearCart,
    completeSale,
    updateSale,
    deleteSale,
    calculateTotals,
    updateProductStorage,
    distributeStock
  };

  return (
    <POSContext.Provider value={value}>
      {children}
    </POSContext.Provider>
  );
};

export function usePOS() {
  const context = useContext(POSContext);
  if (context === undefined) {
    throw new Error('usePOS must be used within a POSProvider');
  }
  return context;
}